"""
The BiMDP package is an extension of the pure feed-forward flow concept in MDP.

It defines a framework for far more general flow sequences, involving
top-down processes (e.g. for error backpropagation) or even loops.
So the 'bi' in BiMDP primarily stands for 'bidirectional'.

BiMDP is implemented by extending both the Node and the Flow concept. Both the
new BiNode and BiFlow classes are downward compatible with the classical
Nodes and Flows, allowing them to be combined with BiMDP elements.

The first fundamental addition in BiMDP is that BiNodes can specify a target
node for their output, to continue the flow execution at the specified target
node. The second new feature is that Nodes can use messages to propagate
arbitrary information, in addition to the standard single array data.
A BiFlow is needed to enable these features, and the BiNode class has adds
convenience functionality to help with this.

Another important addition are the inspection capapbilities (e.g.,
bimdo.show_training), which create and interactive HTML representation of the
data flow. This makes debugging much easier and can also be extended to
visualize data (see the demos in the test folder).

BiMDP fully supports and extends the HiNet and the Parallel packages.


New BiMDP concepts: Jumps and Messages
======================================

Jump targets are numbers (relative position in the flow) or strings, which are
then compared to the optional node_id. The target number 0 refers to the node
itself.
During execution a node can also use the value of EXIT_TARGET (which is
currently just 'exit') as target value to end the execution. The BiFlow
will then return the last output as result.

Messages are standard Python dictionaries to transport information
that would not fit well into the standard x array. The dict keys also support
target specifications and other magic for more convenient usage.
This is described in more detail in the BiNode module.
"""

### T O D O ###

# TODO: add description of coroutine decorator to tutorial,
#    mention that if used it makes the node statefull,  which might be
#    relevant in a clonelayer

# TODO: include SVM based classifiers in the autogenerated biclassifiers

# TODO: make the return value format for stop_training the same as for
#    train and execute, i.e., include x.
#    Terminate when no target value is specified (so for execution add
#    "target": 1 to msg).
#    Remove stop_message method altogether, make execute the default.

# ------------- optional ----------------

# TODO: have BiFlow always return a tuple with message?
#    Having different return types can be confusing.

# TODO: add workaround for Google Chrome issue once a solution for
#    http://code.google.com/p/chromium/issues/detail?id=47416
#    is in place.

# TODO: add a target seperator that does not remove the key. Could use
#    -> remove key
#    --> remove one '-' on entry
#    => do not remove the key
#  Note that adding this kind of magic is relatively cheap in BiNode,
#  in parsing first check just for > .

# TODO: add wildcard support for node_id in message keys.
#    Simply tread the node_id part of the key as a regex and check for match.
#    This adds an overhead of about 1 sec per 100,000 messages.

# TODO: Would it make sense to guarantee that join/fork is always called on
#    the original node? For fork this would prevent caching, for join this
#    would prevent gathering the results in remote nodes/processes.
#    Could be optional depending on node, fork could somehow return a
#    non-forkable node?

# TODO: Implement more internal checks for node output result?
#    Check that last element is not None? Use assume?

# TODO: implement switchlayer, a layer where each column represents a different
#    target, so the target value determines which nodes are used

# TODO: show more information in trace slides via mouse hover,
#    or enable some kind of folding (might be possible via CSS like suckerfish)


from binode import BiNodeException, BiNode, MSG_ID_SEP, binode_coroutine
from biclassifier import BiClassifier
from biflow import (
    MessageResultContainer, BiFlowException, BiFlow, BiCheckpointFlow,
    EXIT_TARGET
)
# the inspection stuff is considered a core functionality
from inspection import *

import nodes
import hinet
import parallel
from test import test

del binode
del biflow
del inspection
